/**
 * Client pour l'API de d√©tection de malware
 * API Endpoint: http://13.53.39.122:5000/predict
 */

export interface MalwareScanResult {
  is_malware: boolean;
  label: 'malware' | 'benign';
  confidence: number;
  prediction: 0 | 1; // 0 = benign, 1 = malware
  probabilities: {
    benign: number;
    malware: number;
  };
}

export interface ScanResponse {
  success: boolean;
  result?: MalwareScanResult;
  error?: string;
  scanTime?: number;
  fileHash?: string;
}

export interface ThreatLevel {
  level: 'critical' | 'high' | 'medium' | 'low' | 'safe';
  color: string;
  icon: string;
  action: 'block' | 'quarantine' | 'warn' | 'allow';
}

const MALWARE_API_URL = 'http://13.53.39.122:5000/predict';

/**
 * Scanner un fichier pour d√©tecter les malwares
 */
export async function scanFile(file: File | Blob): Promise<ScanResponse> {
  const startTime = Date.now();
  
  try {
    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch(MALWARE_API_URL, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }

    const result: MalwareScanResult = await response.json();
    const scanTime = Date.now() - startTime;

    return {
      success: true,
      result,
      scanTime,
    };
  } catch (error) {
    console.error('Malware scan error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Scan failed',
      scanTime: Date.now() - startTime,
    };
  }
}

/**
 * Scanner un fichier depuis son chemin (c√¥t√© serveur)
 */
export async function scanFileFromPath(filePath: string): Promise<ScanResponse> {
  const startTime = Date.now();
  
  try {
    // Lire le fichier et cr√©er un Blob
    const fs = await import('fs/promises');
    const fileBuffer = await fs.readFile(filePath);
    const blob = new Blob([fileBuffer]);

    const formData = new FormData();
    formData.append('file', blob);

    const response = await fetch(MALWARE_API_URL, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }

    const result: MalwareScanResult = await response.json();
    const scanTime = Date.now() - startTime;

    return {
      success: true,
      result,
      scanTime,
    };
  } catch (error) {
    console.error('Malware scan error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Scan failed',
      scanTime: Date.now() - startTime,
    };
  }
}

/**
 * D√©terminer le niveau de menace bas√© sur la confiance
 */
export function getThreatLevel(result: MalwareScanResult): ThreatLevel {
  if (!result.is_malware) {
    return {
      level: 'safe',
      color: 'green',
      icon: '‚úÖ',
      action: 'allow',
    };
  }

  const confidence = result.confidence;

  if (confidence >= 0.9) {
    return {
      level: 'critical',
      color: 'red',
      icon: 'üö®',
      action: 'block',
    };
  } else if (confidence >= 0.7) {
    return {
      level: 'high',
      color: 'orange',
      icon: '‚ö†Ô∏è',
      action: 'quarantine',
    };
  } else if (confidence >= 0.5) {
    return {
      level: 'medium',
      color: 'yellow',
      icon: '‚ö°',
      action: 'warn',
    };
  } else {
    return {
      level: 'low',
      color: 'blue',
      icon: '‚ÑπÔ∏è',
      action: 'warn',
    };
  }
}

/**
 * Formater le pourcentage de confiance
 */
export function formatConfidence(confidence: number): string {
  return `${(confidence * 100).toFixed(2)}%`;
}

/**
 * Obtenir la recommandation d'action
 */
export function getActionRecommendation(result: MalwareScanResult): string {
  const threat = getThreatLevel(result);

  switch (threat.action) {
    case 'block':
      return 'BLOQUER IMM√âDIATEMENT - Menace critique d√©tect√©e';
    case 'quarantine':
      return 'METTRE EN QUARANTAINE - Analyse approfondie requise';
    case 'warn':
      return 'AVERTIR L\'UTILISATEUR - Surveillance recommand√©e';
    case 'allow':
      return 'AUTORISER - Fichier s√ªr';
    default:
      return 'ACTION REQUISE';
  }
}

/**
 * G√©n√©rer un rapport de scan d√©taill√©
 */
export interface ScanReport {
  timestamp: Date;
  result: MalwareScanResult;
  threatLevel: ThreatLevel;
  recommendation: string;
  scanTime: number;
  fileInfo?: {
    name: string;
    size: number;
    type: string;
  };
}

export function generateScanReport(
  response: ScanResponse,
  fileInfo?: { name: string; size: number; type: string }
): ScanReport | null {
  if (!response.success || !response.result) {
    return null;
  }

  const result = response.result;
  const threatLevel = getThreatLevel(result);
  const recommendation = getActionRecommendation(result);

  return {
    timestamp: new Date(),
    result,
    threatLevel,
    recommendation,
    scanTime: response.scanTime || 0,
    fileInfo,
  };
}

/**
 * V√©rifier si l'API est disponible
 */
export async function checkAPIHealth(): Promise<boolean> {
  try {
    const response = await fetch(MALWARE_API_URL.replace('/predict', '/health'), {
      method: 'GET',
      signal: AbortSignal.timeout(5000),
    });
    return response.ok;
  } catch {
    return false;
  }
}

